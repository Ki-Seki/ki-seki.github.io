---
date: '2025-07-25T23:17:51+08:00'
title: 'dowhen 开发过程的启发'
tags: ["dowhen", "python"]
---

## `dowhen` 的 `trigger` 执行流

```python
@classmethod
def when(
    cls,
    entity: CodeType | FunctionType | MethodType | ModuleType | type | None,
    *identifiers: IdentifierType | tuple[IdentifierType, ...],
    condition: str | Callable[..., bool | Any] | None = None,
    source_hash: str | None = None,
):
    # 1. 判定 condition 是否是语法可执行的，类型是否正确

    # 2. 根据 source_hash，判定运行时 entity 是否相对于用户提供时发生变化

    events = []

    # 3. breadth-first 展开 entity 中的 code objects
    code_objects = cls._get_code_from_entity(entity)

    # 4. 根据各类条件定义 trigger events

    # 4.1. 如果没有传 identifiers 参数，all-line matching events
    if not identifiers:
        for code in code_objects:
            events.append(_Event(code, "line", {"line_number": None}))

    # 4.2. 传了 identifiers 参数，普通 events
    else:

        # 4.2.1. 首先要根据没有展开的entity把相对行号转换为绝对行号，因为展开后再计算就可能导致绝对行号在不同code objects里重复出现
        identifiers = cls.unify_identifiers(entity, *identifiers)

        # 4.2.2. 对于每个 identifier × code object，创建对应的事件，其实也可以用itertools.product来简化
        for identifier in identifiers:

            # 4.2.2.1. "<start>" × code object
            if identifier == "<start>":
                for code in code_objects:
                    events.append(_Event(code, "start", None))

            # 4.2.2.2. "<return>" × code object
            elif identifier == "<return>":
                for code in code_objects:
                    events.append(_Event(code, "return", None))
            else:
                for code in code_objects:

                    # 4.2.2.3. 其他标识符 × None
                    if code is None:
                        # Global event, entity is None
                        events.append(
                            _Event(
                                None,
                                "line",
                                {"line_number": None, "identifier": identifier},
                            )
                        )

                    # 4.2.2.4. 其他标识符 × code object
                    else:

                        # 4.2.2.4.1 真正把 identifier 解析为行号，这里要处理各类复杂情形：
                        # 例如，首行匹配问题，comiple得来的code object问题，
                        # identifier的逻辑与和逻辑或关系问题，code object 嵌套问题，
                        # comment等不在co_lines中的语句的trigger问题等
                        line_numbers = get_line_numbers(code, identifier)

                        # 这里得到的 c 是 depth-first 展开的 code objects，确保 trigger 位置正确
                        for c, numbers in line_numbers.items():
                            for number in numbers:
                                events.append(
                                    _Event(c, "line", {"line_number": number})
                                )

    if not events:
        raise ValueError(
            "Could not set any event based on the entity and identifiers."
        )

    # 5. 返回 Trigger 实例
    return cls(events, condition=condition, is_global=entity is None)
```

## `dowhen` 的 `callback` 执行流

```python
被instrumented的代码行
↓
sys.monitoring  # 监听抽象事件以及绑定回调
↓
instrumenter.py::Instrumenter().*_callback()  # sys.monitoring 绑定的回调
↓
instrumenter.py::Instrumenter()._process_handlers()  # 回调高层包装，添加 sys.monitoring.DISABLE 功能
↓
handler.py::EventHandler().__call__()  # 回调中层包装，添加 event 执行时机判定，has_event 和 should_fire 逻辑
↓
callback.py::Callback().__call__()  # 回调低层包装，添加到 call_code/call_goto/call_bp 的判定
↓
callback.py::Callback.call_*()  # 回调执行
↓
用户定义代码  # 如果是 call_code，则执行用户定义的代码
```
